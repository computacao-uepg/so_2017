2c2,27
<   DISCIPLINA: 203065 - Sistemas Operacionais 
---
> DISCIPLINA: 203065 - Sistemas Operacionais
> 
> Shell para execuÔøΩÔøΩo de comandos simples;
> - Esse cÔøΩdigo roda em Linux;
> - O que fazer para portar para o Xv6?
> - ver cÔøΩdigo do sh.c
> 
> 1. Mudado os printf("string") para printf(1, "string") - Sa√≠da padr√£o
> 2. Removidas as bibliotecas stdio e stdlib - N√£o existem no xv6
> 3. Adicionada a biblioteca do printf no xv6 (user.h)
> 4. Removido o par√¢metro do exit - N√£o existe no xv6
> 5. Adicionado o tamanho da string com o comando no gets - Obrigat√≥rio no xv6
> 6. Removido o parametro do wait - Isso talvez n√£o esteja certo, conferir com o dierone
> 7. Adicionada a biblioteca types.h antes da user, ela cont√©m a declara√ß√£o dos tipos
> - Solu√ß√£o poss√≠vel para o futuro: adicionar a defini√ß√£o na pr√≥pria user.h
> - Resolveria a depend√™ncia? Criaria re-declara√ß√µes? Deveria ser feita em outras libraries?
> 8. Mudado de execvp para exec - Isso talvez n√£o esteja certo, conferir com o dierone
> 9. Mudar o NULL para 0 no strtok - NULL n√£o √© definido no xv6
> - Solu√ß√£o poss√≠vel para o futuro: adicionar a constante NULL na types.h
> 10. Arrumar o strtok - Perguntar ao dierone
> - Implementar strtok ou achar alternativa, aparentemente n√£o existe no xv6
> 11. Mudada a saida padr√£o dos erros para a 2 (stderr)
> 12. Adicionado o arquivo da strtok na pasta e incluido o arquivo
> 13. O gets l√™ o \n final
> - Solu√ß√£o: adicionar no strtok o '\n' como delimitador
> - Solu√ß√£o alternativa: adicionar o 0 na ultima posicao do vetor (depois da verifica√ß√£o pra nao dar underflow)
4,7d28
<   Shell para execuÁ„o de comandos simples;
<      - Esse cÛdigo roda em Linux;
<      - O que fazer para portar para o Xv6?
< 		- ver cÛdigo do sh.c
11,12c32,39
< #include <stdlib.h>
< #include <string.h>
---
> #include "types.h" // header com a defini√ß√£o dos tipos usados pela user.h
> 
> #include "user.h" // header com os cabe√ßalhos de syscalls e fun√ß√µes.
> // possui as syscalls aqui usadas: fork, exit, wait, exec
> // possui as fun√ß√µes aqui usadas: strcmp, printf, gets, strlen
> 
> #include "strtok.c" // arquivo com o c√≥digo fonte da fun√ß√£o strtok (n√£o nativa do xv6)
> 
16,41c43,78
<  char lc[ 81 ];
<  char *argv[ 20 ];
<  int pid, i, status;
< 
<  while( 1 ) {
<  	printf( "Prompt > " );
< 	gets( lc );
< 	if( ! strcmp( lc, "" ) )
<  		continue;
<  	argv[ 0 ] = strtok( lc, " " );
<  	if( ! strcmp( argv[ 0 ], "exit" ) )
<  		exit( 0 );
< 	i = 1;
< 	while( i < 20 && (argv[ i ] = strtok( NULL, " " )) )
< 		 ++i;
< 	if( (pid = fork()) == -1 ) {
< 		 printf( "Erro no fork\n" );
< 		 exit( 1 );
< 	}
< 	if( pid == 0 )
< 	if( execvp( argv[ 0 ], argv ) ) {
< 		printf( "Erro no execv\n" );
< 		exit( 1 );
<  	}
< 	 wait( &status );
<  }
---
>   char lc[ 81 ]; // buffer de entrada do shell
>   char *argv[ 20 ]; // vetor de strings para separar os argumentos e fun√ß√µes
>   int pid, i; // process id e contador
> 
>   while( 1 ) { // loop at√© dar sa√≠da
>     printf(1, "Prompt > " ); // escreve na sa√≠da padr√£o (stdout ou 1) que est√° pronto para receber instru√ß√µes
>     gets( lc , 81); // l√™ buffer de entrada
>     if( ! strcmp( lc, "" ) ) // se a entrada n√£o for nula continua a rodar
>     continue;
>     lc[strlen(lc)-1]=0; // retira o \n do fim da string de entrada visto que o gets a l√™
>     // tamanho da string -1 (come√ßa no 0) deve ser nulo pra tirar o \n
>     argv[ 0 ] = strtok( lc, " " ); // carrega o nome da instru√ß√£o para a primeira posi√ß√£o do vetor argv
>     if( ! strcmp( argv[ 0 ], "exit" ) ) // se a instru√ß√£o for sair ent√£o
>     exit(  ); // d√™ a syscall para parar a execu√ß√£o e sair do programa
>     i = 1;
>     while( i < 20 && (argv[ i ] = strtok( 0, " " )) ) // carrega para o vetor argv os par√¢metros da fun√ß√£o lida
>     ++i;
>     if( (pid = fork()) == -1 ) { // se a syscall de fork teve problema
>       printf(2, "Erro no fork\n" ); // escreva na sa√≠da padr√£o de erro(stderr ou 2) que deu erro ao criar o filho
>       exit(  ); // d√™ a syscall para parar a execu√ß√£o e sair do programa
>     }
>     /*
>     A partir do fork existem duas linhas de execu√ß√£o: a do processo filho e a do pai
>     o fork faz com que seja feita uma c√≥pia bin√°ria(byte por byte) do programa que chamou o fork
>     no processo pai a vari√°vel pid recebe a id do processo filho
>     no processo filho a vari√°vel pid recebe 0
>     */
> 
> 
>     if( pid == 0 ) // se esse √© o processo filho
>       if( exec( argv[ 0 ], argv ) ) { // se a execu√ß√£o do filho teve algum problema e n√£o retornou 0
>         printf(2, "Erro no execv\n" ); // escreva na sa√≠da padr√£o de erro(stderr ou 2) que deu erro ao rodar o programa
>         exit(  ); // d√™ a syscall para parar a execu√ß√£o e sair do programa
>     }
>     wait(); // espera o processo filho terminar sua execu√ß√£o para voltar ao come√ßo do loop
>   }
